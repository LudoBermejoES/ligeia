#!/usr/bin/env node

/**
 * Add Extra Mapped Tags to Ligeia Vocabulary
 * 
 * This script extracts the 1,688 extraMappedTags from unmapped-tags-report.json
 * and generates Rust vocabulary data files to add them to the official vocabulary.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const INPUT_FILE = './unmapped-tags-report.json';
const OUTPUT_DIR = './src-tauri/src/data';

// Improved tag categorization based on prefixes and patterns
function categorizeTag(tag) {
  // Genre tags
  if (tag.startsWith('genre:')) {
    return 'genre';
  }
  
  // Mood tags - includes explicit mood: prefix and known mood words
  if (tag.startsWith('mood:') || 
      ['brooding', 'energetic', 'defeat', 'cliffhanger', 'triumph', 'melancholy',
       'serene', 'tense', 'peaceful', 'chaotic', 'hopeful', 'despair'].includes(tag)) {
    return 'mood';
  }
  
  // Occasion tags
  if (tag.startsWith('occasion:')) {
    return 'occasion';
  }
  
  // Everything else goes to keyword (biome:, creature:, element:, etc.)
  return 'keyword';
}

// Generate description for tags
function generateDescription(tag, tagType) {
  if (tagType === 'genre') {
    return `${tag.replace('genre:', '').replace(/-/g, ' ')} music genre`;
  } else if (tagType === 'mood') {
    if (tag.startsWith('mood:')) {
      return `${tag.replace('mood:', '').replace(/-/g, ' ')} emotional state`;
    } else {
      return `${tag.replace(/-/g, ' ')} emotional tone`;
    }
  } else if (tagType === 'occasion') {
    return `${tag.replace('occasion:', '').replace(/-/g, ' ')} scenario`;
  } else {
    // For keywords, generate description based on prefix
    if (tag.includes(':')) {
      const [prefix, value] = tag.split(':', 2);
      const prefixMap = {
        'biome': 'Environmental biome',
        'creature': 'Creature type',
        'element': 'Elemental aspect',
        'faction': 'Organizational faction',
        'character': 'Character reference',
        'diegetic': 'Diegetic sound source',
        'loc': 'Location type',
        'util': 'Utility classification',
        'style': 'Aesthetic style',
        'sfx': 'Sound effect',
        'instrument': 'Musical instrument',
        'technique': 'Musical technique'
      };
      const prefixDesc = prefixMap[prefix] || `${prefix} category`;
      return `${prefixDesc}: ${value.replace(/-/g, ' ')}`;
    }
    return `${tag.replace(/-/g, ' ')} keyword`;
  }
}

// Convert tag to Rust tuple format
function tagToRustTuple(tag, tagType) {
  const description = generateDescription(tag, tagType);
  return `    ("${tagType}", "${tag}", Some("${description}"), None::<&str>)`;
}

// Load and process data
function processExtraTags() {
  console.log('Loading unmapped-tags-report.json...');
  
  if (!fs.existsSync(INPUT_FILE)) {
    throw new Error(`Input file not found: ${INPUT_FILE}`);
  }
  
  const data = JSON.parse(fs.readFileSync(INPUT_FILE, 'utf8'));
  const extraMappedTags = data.extraMappedTags;
  
  console.log(`Found ${extraMappedTags.length} extra mapped tags`);
  
  // Categorize tags
  const categories = {
    genre: [],
    mood: [],
    occasion: [],
    keyword: []
  };
  
  extraMappedTags.forEach(tag => {
    const category = categorizeTag(tag);
    categories[category].push(tag);
  });
  
  console.log('Tag categorization:');
  Object.keys(categories).forEach(cat => {
    console.log(`  ${cat}: ${categories[cat].length} tags`);
  });
  
  return categories;
}

// Generate Rust vocabulary file content
function generateRustVocabulary(tags, tagType) {
  const rustTuples = tags.map(tag => tagToRustTuple(tag, tagType));
  
  return `// Additional ${tagType} tags from extraMappedTags
// Auto-generated by add-extra-tags.js
[
${rustTuples.join(',\n')}
]`;
}

// Read existing vocabulary file and append new tags
function appendToVocabularyFile(filePath, newTags, tagType) {
  if (!fs.existsSync(filePath)) {
    throw new Error(`Vocabulary file not found: ${filePath}`);
  }
  
  const existingContent = fs.readFileSync(filePath, 'utf8');
  
  // Parse existing tags to avoid duplicates
  const existingTags = new Set();
  const tagRegex = /\("[\w-]+",\s*"([^"]+)"/g;
  let match;
  while ((match = tagRegex.exec(existingContent)) !== null) {
    existingTags.add(match[1]);
  }
  
  // Filter out existing tags
  const newUniqueTags = newTags.filter(tag => !existingTags.has(tag));
  
  if (newUniqueTags.length === 0) {
    console.log(`No new tags to add to ${path.basename(filePath)}`);
    return 0;
  }
  
  // Generate new tag entries
  const newRustTuples = newUniqueTags.map(tag => tagToRustTuple(tag, tagType));
  
  // Find the closing bracket and insert before it
  const closingBracketIndex = existingContent.lastIndexOf(']');
  if (closingBracketIndex === -1) {
    throw new Error(`Invalid format in ${filePath} - no closing bracket found`);
  }
  
  // Insert new tags before the closing bracket
  const beforeClosing = existingContent.substring(0, closingBracketIndex).trimEnd();
  const afterClosing = existingContent.substring(closingBracketIndex);
  
  // Add comma if needed
  const needsComma = !beforeClosing.endsWith('[') && !beforeClosing.endsWith(',');
  const comma = needsComma ? ',' : '';
  
  const updatedContent = beforeClosing + comma + '\n    // Extra mapped tags\n' + 
                          newRustTuples.join(',\n') + '\n' + afterClosing;
  
  // Write back to file
  fs.writeFileSync(filePath, updatedContent, 'utf8');
  console.log(`Added ${newUniqueTags.length} new tags to ${path.basename(filePath)}`);
  
  return newUniqueTags.length;
}

// Main function
function main() {
  try {
    console.log('='.repeat(60));
    console.log('Adding Extra Mapped Tags to Ligeia Vocabulary');
    console.log('='.repeat(60));
    
    // Process the extra tags
    const categories = processExtraTags();
    
    // Vocabulary file mappings
    const vocabularyFiles = {
      genre: path.join(OUTPUT_DIR, 'genre_vocabulary.rs'),
      mood: path.join(OUTPUT_DIR, 'mood_vocabulary.rs'),
      occasion: path.join(OUTPUT_DIR, 'occasion_vocabulary.rs'),
      keyword: path.join(OUTPUT_DIR, 'keyword_vocabulary.rs')
    };
    
    let totalAdded = 0;
    
    console.log('\nUpdating vocabulary files...');
    
    // Update each vocabulary file
    Object.keys(categories).forEach(tagType => {
      const tags = categories[tagType];
      const filePath = vocabularyFiles[tagType];
      
      if (tags.length > 0) {
        console.log(`\nProcessing ${tagType} tags (${tags.length} tags)...`);
        const added = appendToVocabularyFile(filePath, tags, tagType);
        totalAdded += added;
      }
    });
    
    console.log('\n' + '='.repeat(60));
    console.log('Summary:');
    console.log(`Total tags processed: ${categories.genre.length + categories.mood.length + categories.occasion.length + categories.keyword.length}`);
    console.log(`Total new tags added: ${totalAdded}`);
    console.log('\nVocabulary files updated successfully!');
    console.log('You can now rebuild the application to use the new vocabulary.');
    console.log('='.repeat(60));
    
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { processExtraTags, generateRustVocabulary, appendToVocabularyFile };